name: Codacy Notification

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  codacy-notification:
    runs-on: ubuntu-latest

    # Do not run on the .github repo, repos containing 'myntr', or PRs with 'Theme Deploy' in title
    if: |
      github.repository != 'Myntr/.github' &&
      !contains(github.repository, 'myntr') &&
      !contains(github.event.pull_request.title, 'Theme Deploy')

    steps:
      - name: Wait for Codacy review
        uses: actions/github-script@v7
        env:
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        with:
          script: |
            console.log(`Starting Codacy notification workflow for PR #${context.issue.number}`);

            // Check if we already notified for this PR
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const alreadyNotified = labels.some(label => label.name === 'codacy-notification');

            if (alreadyNotified) {
              console.log('‚ö†Ô∏è PR author already notified about Codacy review');
              return;
            }

            // Wait 15 minutes to allow Codacy to comment and user to update JIRA status
            const waitTime = 15 * 60 * 1000; // 15 minutes in milliseconds
            console.log(`Waiting 15 minutes before processing PR #${context.issue.number}`);
            await new Promise(resolve => setTimeout(resolve, waitTime));

            console.log(`‚úÖ Wait complete, processing PR #${context.issue.number}`);

            // Get PR details to find the author
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            // Check for Codacy comments
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const { data: reviewComments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const allComments = [...comments, ...reviewComments];
            console.log(`Found ${comments.length} issue comments and ${reviewComments.length} review comments (${allComments.length} total)`);

            // Check if any comment is from Codacy
            const codacyComment = allComments.find(comment =>
              comment.user.login === 'codacy[bot]' ||
              comment.user.login === 'codacy-production[bot]' ||
              comment.user.login === 'codacy-production'
            );

            if (!codacyComment) {
              console.log('‚ö†Ô∏è No Codacy comment found after 15 minutes, workflow will not proceed');
              return;
            }

            console.log(`‚úÖ Codacy comment found from user: ${codacyComment.user.login}`);

            const prAuthor = pr.user.login;
            console.log(`üìù Notifying PR author: ${prAuthor}`);

            // Create notification comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `@${prAuthor} üëã Codacy found code quality issues. Please review and address the comments.`
            });

            // Add label to prevent duplicate notifications
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['codacy-notification']
            });

            console.log('‚úÖ Successfully notified PR author about Codacy review');

            // JIRA Integration - Extract ticket info and update JIRA
            console.log('üé´ Starting JIRA integration');

            try {
              // Extract JIRA ticket ID from PR title (format: "XYZ-110 | Title")
              const jiraTicketMatch = pr.title.match(/^([A-Z]+-\d+)/);
              const jiraTicketFromTitle = jiraTicketMatch ? jiraTicketMatch[1] : undefined;

              // Extract JIRA URL from PR description (gets first URL if multiple exist)
              const jiraUrlMatch = pr.body?.match(/https:\/\/myntr\.atlassian\.net\/browse\/([A-Z]+-\d+)/);
              const jiraTicketFromUrl = jiraUrlMatch ? jiraUrlMatch[1] : undefined;

              console.log(`üîç JIRA ticket from title: ${jiraTicketFromTitle || 'Not found'}`);
              console.log(`üîç JIRA ticket from URL: ${jiraTicketFromUrl || 'Not found'}`);

              // Determine the JIRA ticket ID to use
              let jiraTicketId;

              if (!jiraTicketFromTitle && !jiraTicketFromUrl) {
                console.log('‚ö†Ô∏è No JIRA ticket ID found in either PR title or description');
                return;
              } else if (jiraTicketFromTitle && !jiraTicketFromUrl) {
                jiraTicketId = jiraTicketFromTitle;
                console.log(`üé´ Using JIRA ticket from title: ${jiraTicketId}`);
              } else if (!jiraTicketFromTitle && jiraTicketFromUrl) {
                jiraTicketId = jiraTicketFromUrl;
                console.log(`üé´ Using JIRA ticket from URL: ${jiraTicketId}`);
              } else if (jiraTicketFromTitle === jiraTicketFromUrl) {
                jiraTicketId = jiraTicketFromTitle;
                console.log(`üé´ Both sources match, using JIRA ticket: ${jiraTicketId}`);
              } else {
                jiraTicketId = jiraTicketFromTitle;
                console.log(`‚ö†Ô∏è JIRA ticket mismatch: Title has ${jiraTicketFromTitle}, URL has ${jiraTicketFromUrl}. Using title ID: ${jiraTicketId}`);
              }

              // JIRA API credentials from secrets
              const jiraEmail = process.env.JIRA_EMAIL;
              const jiraToken = process.env.JIRA_API_TOKEN;
              const jiraBaseUrl = 'https://myntr.atlassian.net';

              if (!jiraEmail || !jiraToken) {
                console.log('‚ö†Ô∏è JIRA credentials not configured. Please set JIRA_EMAIL and JIRA_API_TOKEN secrets.');
                return;
              }

              const jiraAuth = Buffer.from(`${jiraEmail}:${jiraToken}`).toString('base64');

              // Get current ticket status
              console.log(`üîç Checking current status of ${jiraTicketId}`);
              const ticketResponse = await fetch(`${jiraBaseUrl}/rest/api/3/issue/${jiraTicketId}`, {
                headers: {
                  'Authorization': `Basic ${jiraAuth}`,
                  'Content-Type': 'application/json'
                }
              });

              if (!ticketResponse.ok) {
                console.log(`‚ùå Failed to fetch JIRA ticket: ${ticketResponse.status} ${ticketResponse.statusText}`);
                return;
              }

              const ticketData = await ticketResponse.json();
              const currentStatus = ticketData.fields.status.name;
              console.log(`üìä Current JIRA ticket status: ${currentStatus}`);

              // Add comment to JIRA ticket
              const jiraComment = {
                body: {
                  type: "doc",
                  version: 1,
                  content: [
                    {
                      type: "paragraph",
                      content: [
                        {
                          type: "text",
                          text: `üîç Codacy found code quality issues in PR #${context.issue.number}. Please review and address the comments.`
                        }
                      ]
                    },
                    {
                      type: "paragraph",
                      content: [
                        {
                          type: "text",
                          text: "PR Link: "
                        },
                        {
                          type: "text",
                          text: pr.html_url,
                          marks: [
                            {
                              type: "link",
                              attrs: {
                                href: pr.html_url
                              }
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              };

              console.log(`üí¨ Adding comment to JIRA ticket ${jiraTicketId}`);
              const commentResponse = await fetch(`${jiraBaseUrl}/rest/api/3/issue/${jiraTicketId}/comment`, {
                method: 'POST',
                headers: {
                  'Authorization': `Basic ${jiraAuth}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(jiraComment)
              });

              if (!commentResponse.ok) {
                console.log(`‚ùå Failed to add JIRA comment: ${commentResponse.status} ${commentResponse.statusText}`);
              } else {
                console.log('‚úÖ Successfully added comment to JIRA ticket');
              }

              // Update ticket status if conditions are met
              const statusesToUpdate = ['Ready for QA', 'Ready for UAT'];
              if (statusesToUpdate.includes(currentStatus)) {
                console.log(`üîÑ Updating ticket status from "${currentStatus}" to "PR Changes Needed"`);

                // Get available transitions
                const transitionsResponse = await fetch(`${jiraBaseUrl}/rest/api/3/issue/${jiraTicketId}/transitions`, {
                  headers: {
                    'Authorization': `Basic ${jiraAuth}`,
                    'Content-Type': 'application/json'
                  }
                });

                if (transitionsResponse.ok) {
                  const transitionsData = await transitionsResponse.json();
                  const targetTransition = transitionsData.transitions.find(t =>
                    t.to.name === 'PR Changes Needed' ||
                    t.name.toLowerCase().includes('changes needed') ||
                    t.name.toLowerCase().includes('needs changes')
                  );

                  if (targetTransition) {
                    const transitionResponse = await fetch(`${jiraBaseUrl}/rest/api/3/issue/${jiraTicketId}/transitions`, {
                      method: 'POST',
                      headers: {
                        'Authorization': `Basic ${jiraAuth}`,
                        'Content-Type': 'application/json'
                      },
                      body: JSON.stringify({
                        transition: {
                          id: targetTransition.id
                        }
                      })
                    });

                    if (transitionResponse.ok) {
                      console.log(`‚úÖ Successfully updated JIRA ticket status to "PR Changes Needed"`);
                    } else {
                      console.log(`‚ùå Failed to update JIRA ticket status: ${transitionResponse.status} ${transitionResponse.statusText}`);
                    }
                  } else {
                    console.log('‚ö†Ô∏è Could not find "PR Changes Needed" transition. Available transitions:', transitionsData.transitions.map(t => t.name));
                  }
                } else {
                  console.log(`‚ùå Failed to get JIRA transitions: ${transitionsResponse.status} ${transitionsResponse.statusText}`);
                }
              } else {
                console.log(`‚ÑπÔ∏è Ticket status "${currentStatus}" does not require update. Only updating from "Ready for QA" or "Ready for UAT".`);
              }

            } catch (jiraError) {
              console.log('‚ùå JIRA integration error:', jiraError.message);
            }